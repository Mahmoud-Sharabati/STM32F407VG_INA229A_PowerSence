/*
 * INA229.c
 *
 *  Created on: Sep 11, 2022
 *      Author: Mahmoud
 */


/*
 *  ======== INA229.c ========
 *  INA229 APIs for initialization and use of the INA229 peripheral
 *
 *  DO NOT EDIT - This file is generated by the SysConfig tool for
 *  the TI Sensors in this application.
 */

#include "INA229.h"

//#define MSB(uint16_t) (((uint16_t) & 0xFF00U) >> 8)
//#define LSB(uint16_t) ((uint16_t) & 0xFFU)

#define maxRegAddress 0x3F

/*---------------------------_Config Struct_--------------------------------*/
/*
 *  ======== INA229_1 ========
 *  INA229 Sensor configuration settings
 *  This struct is copied from config file, and here no need to include config.h any more
 */
static INA229_State INA229_1_state = {

    /* Configuration and Settings */
    .configRegister = (INA229_config_register_rst_NormalOperation | \
                       INA229_config_register_rstacc_NormalOperation | \
					   0b0011111111000000 | \
                       INA229_config_register_tempcomp_Shunttemperaturecompensationdisabled | \
                       INA229_config_register_adcrange_16384mV),
    .adcConfigRegister = (INA229_adc_config_register_mode_Continuousbusvoltageshuntvoltageandtemperature | \
                          INA229_adc_config_register_vbusct_1052us | \
                          INA229_adc_config_register_vshct_1052us | \
                          INA229_adc_config_register_vtct_1052us | \
						  INA229_adc_config_register_avg_1024),
    .shuntCalRegister = 1000,
    .shuntTempcoRegister = 0x004BU, /* TEMPCO is 75 ppm/Â°C */
    .diagAlrtRegister = (INA229_diag_alrt_register_alatch_Transparent | \
                         INA229_diag_alrt_register_cnvr_DisableconversionreadyflagonALERTpin | \
                         INA229_diag_alrt_register_slowalert_ALERTcomparisononnonaveragedADCvalue | \
                         INA229_diag_alrt_register_apol_Normalactivelowopendrain),
    .sovlRegister = 0x7FFFU,
    .suvlRegister = 0x8000U,
    .bovlRegister = 0x7FFFU,
    .buvlRegister = 0x0000U,
    .tempLimitRegister = 0x7FFFU,
    .pwrLimitRegister = 0xFFFFU,

    .adcrange = INA229_config_register_adcrange_16384mV,
    .currentlsb = 0,

    /* Sensor's SPI bus and chip select ID */
    .busId = 0,
    .devCS = 0,

};
const INA229_Handle INA229_1 = &INA229_1_state;

// Register size in bytes
const uint8_t INA229_regSize[maxRegAddress+1] = {
                                            2,2,2,2,3,3,2,3,\
                                            3,5,5,2,2,2,2,2,\
                                            2,2,0,0,0,0,0,0,\
                                            0,0,0,0,0,0,0,0,\
                                            0,0,0,0,0,0,0,0,\
                                            0,0,0,0,0,0,0,0,\
                                            0,0,0,0,0,0,0,0,\
                                            0,0,0,0,0,0,2,2
};
/**/
SPI_HandleTypeDef * INA229_SPI;
TIM_HandleTypeDef * Delay_Timer;
const float current_LSB = 0.0000019073486328125;

/*
 *  ======== INA229_config ========
 * Configure device with current settings.
 */

void INA229_config(INA229_Handle sensor) {
    //Initialize the bus containing this sensor
//    mcu_spiInit(sensor->busId);

    //Write sensor Configuration Registers
    INA229_writeReg(sensor, INA229_config_register, sensor->configRegister);
    INA229_writeReg(sensor, INA229_adc_config_register, sensor->adcConfigRegister);
    INA229_writeReg(sensor, INA229_shunt_cal_register, sensor->shuntCalRegister);
    INA229_writeReg(sensor, INA229_shunt_tempco_register, sensor->shuntTempcoRegister);
    INA229_writeReg(sensor, INA229_diag_alrt_register, sensor->diagAlrtRegister);
    INA229_writeReg(sensor, INA229_sovl_register, sensor->sovlRegister);
    INA229_writeReg(sensor, INA229_suvl_register, sensor->suvlRegister);
    INA229_writeReg(sensor, INA229_bovl_register, sensor->bovlRegister);
    INA229_writeReg(sensor, INA229_buvl_register, sensor->buvlRegister);
    INA229_writeReg(sensor, INA229_temp_limit_register, sensor->tempLimitRegister);
    INA229_writeReg(sensor, INA229_pwr_limit_register, sensor->pwrLimitRegister);
}

/*
 *  ======== INA229_writeReg ========
 * Write register
 */
void INA229_writeReg(INA229_Handle sensor, uint8_t regAddr, uint16_t value)
{
    uint8_t txBuf[3] = {0}; //All writable registers are 2 bytes
//    uint8_t rxBuf[3] = {0};

    txBuf[0] = regAddr << 2; //Address + write bit (ending in 0)
    txBuf[1] = (value >> 8);
    txBuf[2] = (value & 0xFF);

//    uint8_t size = sizeof(txBuf);

    /* Select the INA229: Chip Select low */
	INA229_CS_LOW();
    while (INA229_SPI->State == HAL_SPI_STATE_RESET) {
        HAL_Delay(1);
    }
    if (HAL_SPI_Transmit(INA229_SPI, (uint8_t*)txBuf, (uint16_t)sizeof(txBuf), 200) != HAL_OK) {
        Error_Handler();
    }

    /* Deselect the INA229: Chip Select high */
    INA229_CS_HIGH();

    //check for change in ADCRANGE
    if(regAddr == INA229_config_register)
    {
        sensor->adcrange = value & INA229_config_register_adcrange_4096mV;
    }
}

/*
 *  ======== INA229_readReg ========
 *  Read register
 */
uint64_t INA229_readReg(INA229_Handle sensor, uint8_t regAddr)
{
    while (INA229_SPI->State != HAL_SPI_STATE_READY)
    {
        HAL_Delay(1);
    }
    uint64_t value;

    uint8_t txBuf[1] = {0};
    uint8_t rxBuf[6] = {0}; //max buffer size

    txBuf[0] = (regAddr << 2 ) | 0x01; //Address + read bit (ending in 1)

    //Read register
	/* Pull CS pin Low */
	INA229_CS_LOW();

//	while (INA229_SPI->State == HAL_SPI_STATE_RESET) {
//        HAL_Delay(1);
//    }

	HAL_SPI_Transmit(INA229_SPI, txBuf, 1, HAL_MAX_DELAY);
	HAL_SPI_Receive (INA229_SPI, (uint8_t*)rxBuf, sizeof(rxBuf), HAL_MAX_DELAY);

//    if (HAL_SPI_Transmit(INA229_SPI, (uint8_t*)txBuf, (uint16_t)sizeof(txBuf), 200) != HAL_OK) {
//        Error_Handler();
//    }
//
//    while (HAL_SPI_Receive(INA229_SPI, (uint8_t*)rxBuf, INA229_regSize[regAddr]+1, 200) == HAL_BUSY)
//    {
//        HAL_Delay(1);
//    };


	/* Deselect the INA229: Chip Select high */
    INA229_CS_HIGH();

    //Combine bytes
    value = 0; // initialize to 0, toss rxBuf[0];
    uint8_t RxSize = INA229_regSize[regAddr];

    for(uint8_t i= 0; i < RxSize; i++)
    {
        value = (value << 8) | rxBuf[i];
    }

    return value;
}

/*
 *  ======== INA229_setCURRENT_LSB ========
 *  Set the CURRENT_LSB value used for calculations
 */
void INA229_setCURRENT_LSB(INA229_Handle sensor, float CURRENT_LSB)
{
    sensor->currentlsb = CURRENT_LSB;
}


/*
 *  ======== INA229_getVSHUNT_mV ========
 *  Get VSHUNT value (mV)
 */
float INA229_getVSHUNT_mV(INA229_Handle sensor)
{
    uint64_t value = INA229_readReg(sensor, INA229_vshunt_register);
    float data;

    //Remove reserved bits
    value = value >> 4;

    //Convert for 2's compliment and signed value
    if(value > 0x7FFFF)
    {
        data = (float)value - 0x100000;
    }
    else
    {
        data = (float)value;
    }

    //Convert to mV

    if(sensor->adcrange == INA229_config_register_adcrange_4096mV)
    {
        data = (data * 78.125) / 1000000;
    }
    else
    {
        data = (data * 312.5) / 1000000;
    }

    return data;
}

/*
 *  ======== INA229_getVBUS_V ========
 *  Get VBUS value (V)
 */
float INA229_getVBUS_V(INA229_Handle sensor)
{
    uint64_t value = INA229_readReg(sensor, INA229_vbus_register);
    float data;

    //Remove reserved bits
    value = value >> 4;

    //Convert for 2's compliment and signed value (though always positive)
    if(value > 0x7FFFF)
    {
        data = (float)value - 0x100000; //left for redundancy and error checking, should never get used
    }
    else
    {
        data = (float)value;
    }

    //Convert to V
    data = (data * 195.3125) / 1000000;

    return data;
}

/*
 *  ======== INA229_getDIETEMP_C ========
 *  Get DIETMEP value (C)
 */
float INA229_getDIETEMP_C(INA229_Handle sensor)
{
    uint64_t value = INA229_readReg(sensor, INA229_dietemp_register);
    float data;

    //Convert for 2's compliment and signed value
    if(value > 0x7FFF)
    {
        data = (float)value - 0x10000;
    }
    else
    {
        data = (float)value;
    }

    //Convert to C
    data = (data * 7.8125) / 1000;

    return data;
}

/*
 *  ======== INA229_getDIETEMP_F ========
 *  Get DIETMEP value (F)
 */
float INA229_getDIETEMP_F(INA229_Handle sensor)
{
    float data = INA229_getDIETEMP_C(sensor);

    //Convert to F
    data = (data * (9/5)) + 32;

    return data;
}

/*
 *  ======== INA229_getCURRENT_signedLSB ========
 *  Get CURRENT value (signed value in LSBs)
 */
float INA229_getCURRENT_signedLSB(INA229_Handle sensor)
{
    uint64_t value = INA229_readReg(sensor, INA229_current_register);
    float data;

    //Remove reserved bits
    value = value >> 4;

    //Convert for 2's compliment and signed value
    if(value > 0x7FFFF)
    {
        data = (float)value - 0x100000;
    }
    else
    {
        data = (float)value;
    }

    return data;
}

/*
 *  ======== INA229_getCURRENT_A ========
 *  Get CURRENT value (A)
 */
float INA229_getCURRENT_A(INA229_Handle sensor)
{
    float data = INA229_getCURRENT_signedLSB(sensor);

    data = data * sensor->currentlsb;

    return data;
}

/*
 *  ======== INA229_getPOWER_signedLSB ========
 *  Get POWER value (signed value in LSBs)
 */
float INA229_getPOWER_signedLSB(INA229_Handle sensor)
{
    uint64_t value = INA229_readReg(sensor, INA229_power_register);
    float data;

    data = (float)value;

    return data;
}

/*
 *  ======== INA229_getPOWER_W ========
 *  Get POWER value (W)
 */
float INA229_getPOWER_W(INA229_Handle sensor)
{
    float data = INA229_getPOWER_signedLSB(sensor);

    data = data * sensor->currentlsb * 3.2;

    return data;
}

/*
 *  ======== INA229_getENERGY_signedLSB ========
 *  Get ENERGY value (signed value in LSBs)
 */
double INA229_getENERGY_signedLSB(INA229_Handle sensor)
{
    uint64_t value = INA229_readReg(sensor, INA229_energy_register);
    double data;

    data = (double)value;

    return data;
}

/*
 *  ======== INA229_getENERGY_J ========
 *  Get ENERGY value (J)
 */
double INA229_getENERGY_J(INA229_Handle sensor)
{
    double data = INA229_getENERGY_signedLSB(sensor);

    data = data * sensor->currentlsb * 51.2;

    return data;
}

/*
 *  ======== INA229_getCHARGE_signedLSB ========
 *  Get CHARGE value (signed value in LSBs)
 */
double INA229_getCHARGE_signedLSB(INA229_Handle sensor)
{
    uint64_t value = INA229_readReg(sensor, INA229_charge_register);
    double data;

    //Convert for 2's compliment and signed value
    if(value > 0x7FFFFFFFFF)
    {
        data = (double)value - 0x10000000000;
    }
    else
    {
        data = (double)value;
    }

    return data;
}

/*
 *  ======== INA229_getCHARGE_C ========
 *  Get CHARGE value (C)
 */
double INA229_getCHARGE_C(INA229_Handle sensor)
{
    double data = INA229_getENERGY_signedLSB(sensor);

    data = data * sensor->currentlsb;

    return data;
}

/*---------------------------_MCU Functions_--------------------------------*/
/********* MCU SPECIFIC SPI CODE STARTS HERE**********/

/**
 * @brief Init INA229 SPI
 *
 * @param hspi Pointer to SPI struct handler
 */

void INA229_Init(SPI_HandleTypeDef * hspi, TIM_HandleTypeDef *htim)
{
	HAL_TIM_Base_Start(htim);
	INA229_SPI = hspi;
	Delay_Timer = htim;
	INA229_config(INA229_1);
	INA229_setCURRENT_LSB(INA229_1, current_LSB);
}

/********* MCU SPECIFIC SPI CODE ENDS HERE**********/


/********* MCU SPECIFIC DELAY CODE STARTS HERE************/
void mcu_msWait(unsigned long msWait)
{
    /*
     *  Add MCU specific wait loop for msWait. The unit is in milli-seconds
     */
	HAL_Delay(msWait);
}
/********* MCU SPECIFIC DELAY CODE ENDS HERE************/

/********* START INA299 READING ************/
INA299_Readings Get_INA299_Readings(void) {

	/* Note: in continuous modes (CC), polling rate should
	 *       not exceed sensor conversion rate
	 */
	INA299_Readings sensor_readings;
	uint16_t currentMillis = __HAL_TIM_GET_COUNTER(Delay_Timer);
	static uint16_t previousMillis = 0;
	const uint16_t delay = 100;
	if (__HAL_TIM_GET_COUNTER(Delay_Timer) - previousMillis >= delay)
	{
		sensor_readings.VSHUNT_mV = INA229_getVSHUNT_mV(INA229_1);
		sensor_readings.VBUS_V = INA229_getVBUS_V(INA229_1);
		sensor_readings.CURRENT_A = INA229_getCURRENT_A(INA229_1);
		sensor_readings.DIETEMP_C = INA229_getDIETEMP_C(INA229_1);
		//	mcu_msWait(100); /* delay 1 sec */
		previousMillis = currentMillis;
	}
	return sensor_readings;
}
